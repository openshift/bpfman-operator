apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: test-scripts-access
spec:
  description: |
    Minimal test to prove integration test pipelines can clone the repo
    and execute scripts from it. If this works, we can refactor the
    validation pipeline to use external scripts instead of embedded bash.
  params:
    - name: SNAPSHOT
      description: The JSON string of the Snapshot under test
      type: string
  tasks:
    - name: test-scripts-access
      params:
        - name: SNAPSHOT
          value: $(params.SNAPSHOT)
      taskSpec:
        params:
          - name: SNAPSHOT
            type: string
        results:
          - name: TEST_OUTPUT
            description: Test output in JSON format
        volumes:
          - name: source
            emptyDir: {}
        steps:
          - name: clone
            image: quay.io/konflux-ci/konflux-test:stable
            volumeMounts:
              - name: source
                mountPath: /source
            env:
              - name: SNAPSHOT
                value: $(params.SNAPSHOT)
            script: |
              #!/bin/bash
              set -euo pipefail

              # Extract git URL and revision from first component that has bpfman-operator in its URL
              # (This handles application-level snapshots where COMPONENT_NAME label isn't set)
              REPO_URL=$(echo "$SNAPSHOT" | jq -r '.components[] | select(.source.git.url | contains("bpfman-operator")) | .source.git.url' | head -1)
              REVISION=$(echo "$SNAPSHOT" | jq -r '.components[] | select(.source.git.url | contains("bpfman-operator")) | .source.git.revision' | head -1)

              echo "=== Clone Info ==="
              echo "Repo: $REPO_URL"
              echo "Revision: $REVISION"
              echo ""

              if [ -z "$REPO_URL" ] || [ -z "$REVISION" ]; then
                echo "ERROR: Could not extract repo URL or revision from SNAPSHOT"
                echo "SNAPSHOT contents:"
                echo "$SNAPSHOT" | jq .
                exit 1
              fi

              git clone --depth 1 "$REPO_URL" /source/repo
              cd /source/repo
              git fetch origin "$REVISION" --depth 1
              git checkout "$REVISION"

              echo "Clone complete"

          - name: list-and-run
            image: quay.io/konflux-ci/konflux-test:stable
            volumeMounts:
              - name: source
                mountPath: /source
            script: |
              #!/bin/bash
              set -euo pipefail

              echo "=== Listing hack/konflux/scripts/ ==="
              ls -la /source/repo/hack/konflux/scripts/ || echo "Directory not found"

              echo ""
              echo "=== Environment Discovery ==="
              echo "Listing /usr/bin:"
              ls /usr/bin | sort | tr '\n' ' '
              echo ""
              echo ""
              echo "Listing /usr/local/bin:"
              ls /usr/local/bin 2>/dev/null | sort | tr '\n' ' ' || echo "(empty or not found)"
              echo ""
              echo ""
              echo "Checking for python:"
              which python python3 2>/dev/null || echo "python/python3 not in PATH"
              echo ""
              echo "Checking for podman/skopeo:"
              which podman skopeo 2>/dev/null || echo "podman/skopeo not in PATH"
              echo ""

              echo "=== Running hello.sh ==="
              if [ -f /source/repo/hack/konflux/scripts/hello.sh ]; then
                bash /source/repo/hack/konflux/scripts/hello.sh
              else
                echo "Script not found at /source/repo/hack/konflux/scripts/hello.sh"
              fi

              echo ""
              echo "=== Running hello.py ==="
              if [ -f /source/repo/hack/konflux/scripts/hello.py ]; then
                python3 /source/repo/hack/konflux/scripts/hello.py
                RESULT="SUCCESS"
              else
                echo "Script not found at /source/repo/hack/konflux/scripts/hello.py"
                RESULT="FAILURE"
              fi

              echo ""
              TIMESTAMP=$(date -u +%s)
              echo "{\"result\":\"$RESULT\",\"timestamp\":\"$TIMESTAMP\",\"failures\":0,\"successes\":1,\"warnings\":0}" | tee $(results.TEST_OUTPUT.path)
